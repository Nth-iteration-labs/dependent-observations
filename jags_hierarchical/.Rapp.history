plot(x,y)
abline(lm(y~x))
y <- c(y, 14)
x <- c(x, 4.5)
plot(x,y)
abline(lm(y~x))
x <- c(1:100)
y <- .1^x
plot(y,x)
plot(x,y)
y <- 1.1^x
plot(x,y)
logy <- log(y)
plot(x,y)
plot(x,logy)
ls
ls()
http://www.datall-analyse.nl/R/PF.R
rm(list = ls())
ls()
load("data/aselected.RData")
?mode
x <- ribinom(100, .1, 1:10)
x <- rbinom(100, .1, 1:10)
x
x <- rbinom(100, 1:10, .1)
x
unique(x)
tabulate(x)
un <- unique(x)
match(x, un)
tabulate(math(x, un))
tabulate(match(x, un))
which.max(tabulate(match(x,un)))
unique[which.max(tabulate(match(x,un)))]
un[which.max(tabulate(match(x,un)))]
sort(x)
install.packages("bla")
rchisq()
dchisq(9.375,1)
dchisq(9.375,1)*2
dnorm(0)
pnorm(0)
pchisq(9.375,1)
1-pchisq(9.375,1)
x <- rnorm(100,0,1)
y <- x + rnorm(100,0,1)
corr(y,x)
cor(x,y)
x <- x * 10
cor(x,y)
cov(x,y)
x <- x / 10
cov(x,y)
M<-matrix(c(1:8), ncol=2)
dim(M)
M
M[4,]
x1 <- c(12,10,15,22,23,20)
mean(x1)
sum(x1)
sum(x1)/5
var(x1)
?var
((n-1)/n) * var(x1)
((6-1)/6) * var(x1)
sd(x1)
((6-1)/6) * sd(x1)
x2 <- rnorm(1000,10,2)
x3 <- x2^2
cor(x2,x3)
x2 <- rnorm(1000,0,2)
x3 <- x2^2
cor(x2,x3)
data<-data.frame(age=rnorm(10,20,2), gender=rbinom(10,1,.5), lenght=rnorm(10,175,5))
library(xtable)
xtable(data)
meidan(age)
median(data$age)
data<-data.frame(age=round(rnorm(10,20,2)), gender=rbinom(10,1,.5), lenght=rnorm(10,175,5))
xtable(data)
median(data$age)
plot(data$age, data$gender)
plot(data$age, factor(data$gender))
plot(data$gender, data$length)
data$length
plot(data$gender, data$lenght)
plot(data$age, data$lenght)
plot(data$age)
boxplot(data$age)
n <- 1000
price <- runif(n, 50000, 600000)
size <- runif(n, 50, 350)
location <- rbinom(n, 1, .7)
rooms <- runif(n,2,7)
price <- 100000 + size*10000 - (size^2-mean(size)) * 2 + location*20000 + 2000*rooms + rnorn(n,0,1000)
price <- 100000 + size*10000 - (size^2-mean(size)) * 2 + location*20000 + 2000*rooms + rnorm(n,0,1000)
plot(size,price)
price <- 100000 + size*1000 - (size^2-mean(size)) * 2 + location*5000 + 200*rooms + rnorm(n,0,1000)
plot(size,price)
price <- 100000 + size*1000 - (size^2-mean(size)) * .3 + location*5000 + 200*rooms + rnorm(n,0,1000)
plot(size,price)
price <- 100000 + size*1000 - (size^2-mean(size)) * .6 + location*5000 + 200*rooms + rnorm(n,0,10000)
plot(size,price)
price <- 100000 + size*1000 - (size^2-mean(size)) * .9 + location*5000 + 200*rooms + rnorm(n,0,10000)
plot(size,price)
data <- data.frame(Size = size, Price = price, City = location, Rooms = rooms)
library(xtable)
xtable(head(data))
data$City <- as.factor(data$City)
xtable(summary(data))
lm(Price ~ Size + Rooms + Price, data=data)
lm(Price ~ Size + City + Rooms, data=data)
xtable(summary(lm(Price ~ Size + City + Rooms, data=data)))
summary(lm(Price ~ Size + City + Rooms, data=data))
install.packages("rstan", repos = "https://cloud.r-project.org/", dependencies=TRUE)
fx <- inline::cxxfunction( signature(x = "integer", y = "numeric" ) , '#
    return ScalarReal( INTEGER(x)[0] * REAL(y)[0] ) ;#
' )#
fx( 2L, 5 )
library("rstan")
rstan_options(auto_write = TRUE)#
options(mc.cores = parallel::detectCores())
data {#
  int<lower=0> J; // number of schools #
  real y[J]; // estimated treatment effects#
  real<lower=0> sigma[J]; // s.e. of effect estimates #
}#
parameters {#
  real mu; #
  real<lower=0> tau;#
  real eta[J];#
}#
transformed parameters {#
  real theta[J];#
  for (j in 1:J)#
    theta[j] = mu + tau * eta[j];#
}#
model {#
  target += normal_lpdf(eta | 0, 1);#
  target += normal_lpdf(y | theta, sigma);#
}
tab <- table(c(c(93,38),c(42,11)))
tab
tab <- table(c(c(93,38),c(42,11)), nrow=2)
tab <- table(c(93,38),c(42,11))
tab
?table
M <- matrix(c(93,38,41,11),nrow=2)
M
chisq.test(M)
chisq.test(M, correct=FALSE)
sum(M)
.8 / sqrt(4 * 4)
t(M)
chisq.test(t(M), correct=FALSE)
M
chisq.test(M)
chisq.test(M, correct=FALSE)
chisq.test(M)
M2 <- matrix(c(93,38,42,11), nrow=2)
M2
chisq.test(M2)
chisq.test(M2, correct=FALSE)
m1 <- mean(c(0,4))
m2 <- mean(c(2:6))
m1 <- mean(c(0:4))
m3 <- mean(c(7:9))
m3
m1
m2
1/4*m1+1/2*m2+1/4*m3
factorial(1)
factorial(2)
factorial(factorial(2))
factorial(factorial(factorial(3)))
1!
factorial(3)
0
factorial(1)
factorial(factorial(2))
factorial(3)
factorial(factorial(3))
factorial(720)
x <- 5*5*4*4*3
choose(x, 14)
choose(x, 14)*2
install.packages("Rcpp", type="source")
library(Rcpp)
install.packages("devtools")
install.packages("Rcpp")
install.packages("rstan", repos = "https://cloud.r-project.org/", dependencies=TRUE)
library(BayesTree)
?BayesTree
?bart
M <- matrix(0, nrow=2, ncol=3)
M
4
4%%3
0%%3
1%%3
2%%3
3%%3
4%%3
5%%3
x <- rep(.1, 10)
x
mean(x)
sd(x)
var(x)
sum(x)
x <- rbeta(10000, 2,8)
plot(density(x)
)
x2 <- x * 10
plot(density(x2))
plot(density(rbeta(10000,5,5)*10)
)
plot(density(rbeta(10000,5,5)*10))
p1 <- rbeta(1000,5,5)
p2 <- .35
plot(density(p1))
abline(v=p2)
p1 <- rbeta(10000,5,5)
sum(ifelse(p1<p2),1,0)
sum(ifelse(p1<p2,1,0))
p1 <- rbeta(10000,4,4)
sum(ifelse(p1<p2,1,0))
.35+.8
1.15/2*5000
userid <- c(1:100)
userid/2 + 30
(userid-50)*.2 + 50
(userid-50)*.3 + 60
userid <- c(1:100)
age <- userid/2 + 30
weight  <- (userid-50)*.6+75
dat <- data.frame(userid, age, weight)
dat
head(dat)
steps <- 9000 + 10*(80-weight)^2 - 20*age
steps
mean(steps)
steps <- 9000 + 10*(80-weight)^2 - 20*age - 1000 + (30*(10000-10000)^2)
steps
library(devtools)	#
install_github(“MKaptein/ofmlr”)#
library(ofmlr)#
?ofmlr
library(devtools)
install_github(“MKaptein/ofmlr”)
install_github("MKaptein/ofmlr")
library(ofmlr)#
?ofmlr
?ofmlr
library(devtools)	#
install_github(“MKaptein/ofmlr”)#
library(ofmlr)#
?ofmlr
setwd('/Users/mauritskate/Desktop/BetaBeta')
# Have Jags installed, and rjags package:#
library('rjags')
setwd('/Users/mauritskate/Desktop/BetaBeta')
J <- 10			# Number of people#
i <- 100		# Number of observations pp#
N <- i*j		# Total number#
#
# id vector#
id <- sapply(1:(N), function(x) { ( (x-1) %/% i)  + 1 } )#
#
# Grand mean, and individual level mean#
p.j <- rbeta(J, 1,1)#
#
# Simulate i binary observations w. probablity p.j#
y <- as.vector(sapply(p.j, function (x) { rbinom(i, 1, x) } ) ) #
#
## The Buggs model#
jags <- jags.model(#
                   'beta-multi2.jags',#
                   data = list('y' = y, 'J'=J, 'id'=id, 'N'=N),#
                   n.chains = 4,#
                   n.adapt = 100)#
#
# Get posterior samples for a[j] and b[j]#
#samples <- coda.samples(jags, c('a', 'b'), 10000);#
#plot(samples)#
#
# For checking, get posterior p only and compute mean#
samples2 <- coda.samples(jags, c('p'), 10000);
setwd('/Users/mauritskate/Desktop/BetaBeta')
J <- 10			# Number of people#
i <- 100		# Number of observations pp#
N <- i*J		# Total number#
#
# id vector#
id <- sapply(1:(N), function(x) { ( (x-1) %/% i)  + 1 } )#
#
# Grand mean, and individual level mean#
p.j <- rbeta(J, 1,1)#
#
# Simulate i binary observations w. probablity p.j#
y <- as.vector(sapply(p.j, function (x) { rbinom(i, 1, x) } ) ) #
#
## The Buggs model#
jags <- jags.model(#
                   'beta-multi2.jags',#
                   data = list('y' = y, 'J'=J, 'id'=id, 'N'=N),#
                   n.chains = 4,#
                   n.adapt = 100)
setwd('/Users/mauritskate/Desktop/BetaBeta')
## The Buggs model#
jags <- jags.model(#
                   'beta-multi2.jags',#
                   data = list('y' = y, 'J'=J, 'id'=id, 'N'=N),#
                   n.chains = 4,#
                   n.adapt = 100)
setwd('/Users/mauritskate/Desktop/BetaBeta')
## The Buggs model#
jags <- jags.model(#
                   'beta-multi2.jags',#
                   data = list('y' = y, 'J'=J, 'id'=id, 'N'=N),#
                   n.chains = 4,#
                   n.adapt = 100)
setwd('/Users/mauritskate/Desktop/BetaBeta')
## The Buggs model#
jags <- jags.model(#
                   'beta-multi2.jags',#
                   data = list('y' = y, 'J'=J, 'id'=id, 'N'=N),#
                   n.chains = 4,#
                   n.adapt = 100)
setwd('/Users/mauritskate/Desktop/BetaBeta')
samples2 <- coda.samples(jags, c('p'), 10000);
setwd('/Users/mauritskate/Desktop/BetaBeta')
# Check difference for first chain:#
colMeans(samples2[[1]]) - p.j
setwd('/Users/mauritskate/Desktop/BetaBeta')
colMeans(samples2[[1]])
setwd('/Users/mauritskate/Desktop/BetaBeta')
p.j
